{"version":3,"sources":["../src/constants.ts"],"names":[],"mappings":"AACA,YAAY,CAAC;;AACb,IAAkB,MAKjB;AALD,WAAkB,MAAM;IACtB,yCAAW,CAAA;IACX,mCAAQ,CAAA;IACR,yCAAW,CAAA;IACX,yCAAW,CAAA;AACb,CAAC,EALiB,MAAM,GAAN,cAAM,KAAN,cAAM,QAKvB;AAED,IAAkB,IAGjB;AAHD,WAAkB,IAAI;IACpB,2CAAc,CAAA;IACd,uCAAY,CAAA;AACd,CAAC,EAHiB,IAAI,GAAJ,YAAI,KAAJ,YAAI,QAGrB;AAcA,CAAC;AAWF;IAAA;QACE,aAAQ,GAAY,CAAC,CAAC;QACtB,kBAAa,GAAY,CAAC,CAAC;QAC3B,gBAAW,GAAY,CAAC,CAAC;QACzB,qBAAgB,GAAY,CAAC,CAAC;QAC9B,aAAQ,GAAW,CAAC,CAAC;QACrB,cAAS,GAAW,CAAC,CAAC;IACxB,CAAC;CAAA;AAPD,0BAOC;AAcA,CAAC;AAeD,CAAC;AAsBD,CAAC;AAUD,CAAC;AAqBD,CAAC","file":"constants.js","sourcesContent":["\n\"use strict\";\nexport const enum Status {\n  RUNNING = 0,\n  DONE = 2,\n  STOPPED = 1,\n  INITIAL = 3\n}\n\nexport const enum Mode {\n  SEQUENTIAL = 0,\n  PARALLEL = 1\n}\n\nexport interface ISQLExecutor {\n  execStatement : (statement: string) => Promise<Object>\n}\n\n\n\nexport interface IRun {\n  index: number,\n  statement : string,\n  status: Status,\n  duration : number,\n  executor : ISQLExecutor\n};\n\nexport interface IMetrics {\n  parallel : number,\n  count_total : number,\n  count_started : number,\n  count_ok : number,\n  sum_duration_all : number,\n  count_bad : number,\n}\n\nexport class Metrics implements IMetrics {\n  parallel : number = 0;\n  count_started : number = 0;\n  count_total : number = 0;\n  sum_duration_all : number = 0;\n  count_ok: number = 0;\n  count_bad: number = 0;\n}\n\nexport interface IParallelExecutor {\n  stopOp : (string) => void,\n  triggerLoop : () => void,\n  startOpSequential: (tag : string, statement: string, cb : ICallbacks) => string,\n  startSequentialSimple(statement : string) : Promise<any>,\n  changeParallelOp: (handle: string, parallel: number) => void,\n  startOpRepeat: (\n    tag: string,\n    statement: string,\n    parallel: number,\n    options?: IOptions,\n    cb? : ICallbacks) => string\n};\n\n\n/**\n * Record of a result received\n */\nexport interface IResultRec {\n  ts : string,\n  /**\n   * Time, absolute (Date.now())\n   */\n  t : number,\n  delta_t : number,\n  rc : boolean,\n  res : any\n};\n\n/**\n * allows to\n */\nexport interface ICallbacks {\n  done? : ( op : IParallelOp ) => void,\n  /**\n   * Always invoked on any response\n   */\n  progress? : ( op : IParallelOp, rc? : boolean ) => void,\n  /**\n   * Only invoked on successful results\n   */\n  result? : (err : object, result : any) => void\n}\n\nexport type ITimingMap = Map<string, Map<number, number> >;\n\nexport interface ITimingRec {\n  time : number,\n  rec : ITimingMap\n};\n\n\nexport interface IOptions {\n  continuous : boolean,\n  forcename? : string,\n  terminate_nr? : number,\n  terminate_delta_t? : number,\n  every_t? : number,\n  t_last? : number\n};\n\nexport interface IParallelOp {\n  tag : string,\n  name: string,\n  statement: string,\n  status: Status,\n  parallel: number,\n  cps : any[],\n  cp_running: number,\n  options : IOptions,\n  mode : Mode,\n  t_started : number,  /* number in ms when this was started*/\n  logit?: (a: string) => void,\n  slots: IRun[],\n  allresults : IResultRec[],\n  timings : ITimingRec[],\n  metrics : IMetrics,\n  callbacks? : ICallbacks,\n  lastResult? : any,\n  lastRC? : boolean\n};\n\n"],"sourceRoot":"."}