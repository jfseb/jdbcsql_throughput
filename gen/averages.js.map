{"version":3,"sources":["../src/averages.ts"],"names":[],"mappings":";;AAGA,mDAA+C;AAC/C,mDAA+C;AAE/C,wDAAwD;AACxD,+BAA+B;AAE/B,MAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC;AACnC,YAAY,CAAC;AAEb;;GAEG;AACH,IAAkB,YAIjB;AAJD,WAAkB,YAAY;IAC5B,qDAAW,CAAA;IACX,+CAAI,CAAA;IACJ,iDAAK,CAAA;AACP,CAAC,EAJiB,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAI7B;AAkBD,uFAAuF;AACvF,2CAA2C;AAE3C,IAAI,KAAK,GAAG,CAAC,CAAC;AACd,IAAI,UAAU,GAAG,EAAE,CAAC;AAEpB,IAAI,QAAQ,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC;AACvC,IAAI,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AAK/B,IAAI,OAAO,GAAkB,SAAS,CAAC;AACvC,IAAI,OAAO,GAAuB,SAAS,CAAC;AAE5C;;;;;;;;;;;;;;;;;;GAkBG;AAGH,IAAI,OAAO,GAAY,CAAC,CAAC;AAEzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgEE;AAGF,IAAI,IAAI,GAAG,CAAC,CAAC;AAEb,wBAA+B,OAA2B;IAExD,OAAO,CAAC,aAAa,CACnB,SAAS,EACT,6CAA6C,EAC7C,CAAC,EACD;QACE,SAAS,EAAG,SAAS;QACrB,UAAU,EAAG,IAAI;QACjB,MAAM,EAAG,CAAC;QACV,OAAO,EAAG,IAAI;KACf;IACD,eAAe;IACf;QACE,MAAM,EAAG,UAAS,GAAG,EAAE,GAAG;YACxB,EAAE,CAAA,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACR,IAAI,MAAM,GAAG,gBAAgB,CAAC,GAAG,CAAC,CAAC;gBACnC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,MAAM,CAAC,CAAC;YACrC,CAAC;QACH,CAAC;KACF,CACF,CAAA;IACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAkCA;AACF,CAAC;AAzDD,wCAyDC;AAED,IAAI,GAAG,GAAG,CAAC,CAAC;AAEZ,yBAAyB;AAGzB;;;;GAIG;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AAEH,sBAA6B,EAAgB;IAC3C,IAAI,GAAG,GAAG,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC;IAC/C,OAAO,CAAC,GAAG,CAAC,iBAAiB,GAAG,EAAE,CAAC,OAAO,CAAC,WAAW,GAAG,YAAY,GAAG,CAAC,EAAE,CAAC,OAAO,IAAI,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;IAC3G,EAAE,CAAA,CAAE,EAAE,CAAC,OAAO,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/B,OAAO,CAAC,GAAG,CAAE,EAAE,CAAC,OAAO,CAAC,WAAW,GAAG,IAAI,GAAG,EAAE,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,SAAS,CAAC,GAAG,QAAQ,GAAG,CAAC,EAAE,CAAC,OAAO,CAAC,SAAS,GAAG,GAAG,GAAG,EAAE,CAAC,OAAO,CAAC,WAAW,CAAC,GAAI,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1L,CAAC;AACH,CAAC;AAND,oCAMC;AAeA,CAAC;AAEF,kBAAyB,EAAgB;IACvC,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;IAC7B,IAAI,GAAG,GAAG,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC;IAC/C,OAAO,CAAC,GAAG,CAAE,EAAE,CAAC,OAAO,CAAC,WAAW,GAAG,IAAI,GAAG,EAAE,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,SAAS,CAAC,GAAG,MAAM,GAAG,CAAC,EAAE,CAAC,OAAO,CAAC,SAAS,GAAG,GAAG,GAAG,EAAE,CAAC,OAAO,CAAC,WAAW,CAAC,GAAI,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;IACtL,IAAI,IAAI,GAAS,GAAG,CAAC,MAAM,CAAC;IAC5B,OAAO,CAAC,GAAG,CAAE,kBAAkB;UACrB,QAAQ;UACR,QAAQ;UACR,YAAY;UACZ,SAAS;UACT,SAAS;UACT,QAAQ;UACR,UAAU;UACV,UAAU;UACV,4BAA4B,CAC7B,CAAA;IACT,IAAI,MAAM,GAAa;QACrB,GAAG,EAAG,EAAE,CAAC,GAAG;QACZ,GAAG,EAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,WAAW,GAAG,IAAI,GAAG,EAAE,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;QAClF,GAAG,EAAG,CAAC,EAAE,CAAC,OAAO,CAAC,SAAS,GAAG,GAAG,GAAG,EAAE,CAAC,OAAO,CAAC,WAAW,CAAC;QAC3D,GAAG,EAAI,CAAC,EAAE,CAAC,QAAQ,CAAE;QACrB,GAAG,EAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,gBAAgB,GAAG,CAAC,GAAG,GAAC,EAAE,CAAC,OAAO,CAAC,WAAW,CAAE,CAAC,GAAC,EAAE;QAChF,GAAG,EAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,gBAAgB,GAAG,CAAC,GAAG,GAAC,EAAE,CAAC,QAAQ,GAAC,EAAE,CAAC,OAAO,CAAC,WAAW,CAAE,CAAC,GAAC,EAAE;QAC5F,IAAI,EAAG,IAAI,CAAC,YAAY;QACxB,GAAG,EAAI,IAAI,CAAC,eAAe;QAC3B,GAAG,EAAG,IAAI,CAAC,eAAe;QAC1B,GAAG,EAAG,IAAI,CAAC,SAAS;QACpB,KAAK,EAAG,IAAI,CAAC,aAAa;QAC1B,KAAK,EAAI,IAAI,CAAC,gBAAgB;QAC9B,KAAK,EAAG,IAAI,CAAC,uBAAuB;KACrC,CAAC;IACF,cAAc,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;IACzB,OAAO,CAAC,GAAG,CAAE,MAAM,CAAC,GAAG;QAClB,CAAE,KAAK,GAAG,MAAM,CAAC,GAAG;UAClB,KAAK,GAAG,MAAM,CAAC,GAAG;UAClB,KAAK,GAAG,CAAC,EAAE,CAAC,QAAQ,CAAE;UACtB,KAAK,GAAG,MAAM,CAAC,GAAG,EACpB,CAAE,KAAK,GAAG,MAAM,CAAC,GAAG,EACpB,CAAE,KAAK,GAAG,IAAI,CAAC,YAAY;UACzB,QAAQ,GAAG,IAAI,CAAC,eAAe;UAC/B,KAAK,GAAG,MAAM,CAAC,GAAG,EACpB,CAAE,KAAK,GAAG,MAAM,CAAC,GAAG,EACpB,CAAE,KAAK,GAAG,IAAI,CAAC,gBAAgB;UAC7B,KAAK,GAAG,IAAI,CAAC,aAAa;UAC1B,KAAK,GAAG,IAAI,CAAC,uBAAuB,CAC1C,CAAC;IACF,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AA/CD,4BA+CC;AAED,0BAAiC,GAAS;IACxC,IAAI,MAAM,GAAgB,IAAI,GAAG,EAAgC,CAAC;IAClE,YAAI,CAAC,OAAO,CAAC,GAAG;QACd,GAAG,CAAC,OAAO,CAAE,GAAG;YACd,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC;gBACpB,QAAQ,CAAE,gBAAgB,GAAG,GAAG,CAAC,KAAK,GAAG,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;gBACpE,EAAE,CAAA,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBACpB,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,GAAG,EAAiB,CAAC,CAAC;gBAC5C,CAAC;gBACD,IAAI,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACzB,EAAE,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;YAChD,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AAfD,4CAeC;AAED,wBAAgC,IAAa,EAAE,GAAgB;IAE7D,IAAI,OAAO,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC;IACnC,OAAO,CAAC,OAAO,CAAC,UAAS,IAAI;QAC3B,IAAI,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC7B,EAAE,CAAA,CAAC,EAAE,CAAC,MAAM,mBAAkB,CAAC,CAC/B,CAAC;YACC,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAG,IAAI,EAAE,GAAG,EAAG,GAAG,EAAC,CAAC,CAAC;YAC3C,QAAQ,CAAE,0BAA0B,GAAG,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAC5D,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAXD,wCAWC;AAED,qBAA4B,KAAc,EAAE,GAAY;IAEtD,MAAM,CAAC,KAAK,GAAG,CAAC,GAAG,GAAG,KAAK,CAAC,GAAC,GAAG,CAAC;AACnC,CAAC;AAHD,kCAGC;AAED,sBAA8B,KAAc,EAAE,GAAY;IAExD,MAAM,CAAC,CAAC,GAAG,GAAC,KAAK,CAAC,GAAG,GAAG,CAAC;AAC3B,CAAC;AAHD,oCAGC;AAED;IAUE;QATA,sBAAiB,GAAY,CAAC,CAAC;QAC/B,cAAS,GAAY,CAAC,CAAC;QACvB,4BAAuB,GAAY,CAAC,CAAC;QACrC,kBAAa,GAAY,CAAC,CAAC;QAC3B,oBAAe,GAAY,CAAC,CAAC;QAC7B,oBAAe,GAAY,CAAC,CAAC;QAC7B,iBAAY,GAAY,CAAC,CAAC;QAC1B,qBAAgB,GAAY,CAAC,CAAC;QAC9B,uBAAkB,GAAY,CAAC,CAAC;IACjB,CAAC;CACjB;AAXD,gCAWC;AAAA,CAAC;AAEF;IAAA;QACE,SAAI,GAAY,CAAC,CAAC;QAClB,QAAG,GAAY,CAAC,CAAC;QACjB,WAAM,GAAgB,IAAI,UAAU,EAAE,CAAC;IACzC,CAAC;CAAA;AAJD,0BAIC;AAAA,CAAC;AAEW,QAAA,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,UAAU,EAAE,CAAC,CAAC,CAAC;AAC9D,oBAA2B,KAAc,EAAG,IAAoB;IAE9D,mCAAmC;IACnC,+DAA+D;IAC/D,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAE,CAAC,IAAI,EAAC,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,GAAE,OAAO,CAAC,IAAI,GAAE,IAAI,EAAG,CAAC,CAAC,CAAC;IAC/F,MAAM,SAAS,GAAG,WAAW,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC/C,QAAQ,CAAE,OAAO,GAAG,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,MAAM,GAAG,CAAC,QAAQ,GAAG,OAAO,CAAC,GAAG,OAAO,GAAG,CAAE,SAAS,GAAG,OAAO,CAAC,CAAE,CAAC;IAC3G,EAAE,CAAA,CAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CACpB,CAAC;QACC,OAAO,CAAC,GAAG,CAAC,4BAA4B,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;IAC1D,CAAC;IACD,IAAI,CAAC,OAAO,CAAC,GAAG,IACd,QAAQ,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;IAC1C,MAAM,aAAa,GAAG,IAAI,CAAC,MAAM,CAAE,CAAC,IAAI,EAAE,OAAO,KAAM,CAAC,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,SAAS,CAAC,CAAC,GAAG,OAAO,GAAG,IAAI,EAAG,SAAS,CAAC,CAAC;IAC3H,IAAI,MAAM,GACV;QACE,IAAI,EAAG,CAAC;QACR,GAAG,EAAG,CAAC;QACP,MAAM,EAAG,IAAI,UAAU;KACxB,CAAC;IACF,MAAM,QAAQ,GAAG,YAAY,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC/C,QAAQ,CAAC,kBAAkB,GAAG,QAAQ,CAAC,CAAC;IACxC,IAAI,eAAe,GAAG,CAAC,CAAC;IACxB,EAAE,CAAC,CAAE,aAAc,CAAC,CACpB,CAAC;QACC,QAAQ,CAAC,qBAAqB,CAAC,CAAC;QAChC,YAAI,CAAC,OAAO,CAAC,GAAG;YAChB,IAAI,GAAG,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACrC,IAAI,YAAY,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAE,CAAC,CAAC,EAAC,CAAC,KAAK,CAAC,GAAC,CAAC,CAAC,CAAC;YAC1F,QAAQ,CAAC,cAAc,GAAG,YAAY,CAAC,CAAC;YACxC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,IAAI;gBAE/C,EAAE,CAAA,CAAC,CAAC,IAAI,GAAG,QAAQ,CAAC,CAAC,CACrB,CAAC;oBACC,eAAe,GAAG,IAAI,CAAC;oBACvB,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBACvB,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,MAAM,CAAC,IAAI,CAAC;gBACb,CAAC;YACH,CAAC,EACA,CAAC,CAAC,CAAC;QACN,CAAC,CAAC,CAAC;IACL,CAAC;IACH,QAAQ,CAAC,UAAU,GAAG,eAAe,CAAC,CAAC;IACvC,MAAM,CAAC,GAAG,GAAG,eAAe,CAAC;IAC7B,MAAM,CAAC,IAAI,GAAG,aAAa,IAAI,aAAa,CAAC,IAAI,CAAC;IAClD,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AA/CD,gCA+CC;AAED,kBAAyB,CAAO,EAAE,GAAY;IAC5C,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACf,OAAM,CAAC,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;QACrB,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;IACd,CAAC;IACD,MAAM,CAAC,CAAC,CAAC;AACX,CAAC;AAND,4BAMC;AAGC,oEAAoE;AAEpE,0HAA0H;AAC1H,uEAAuE;AACvE,0GAA0G;AAC1G,uEAAuE;AAGzE,wBAA+B,SAAqB;IAClD,EAAE,CAAA,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;QACzB,MAAM,CAAC;IACT,CAAC;IACD,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAE,GAAG,IAAI,QAAQ,CAAC,GAAG,EAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC3E,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAChB,SAAS,CAAC,OAAO,CAAC,KAAK;QAErB,IAAI,EAAE,GAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAE,GAAG,IAAI,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,EAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC5E,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAClB,CAAC,CAAC,CAAC;AACL,CAAC;AAXD,wCAWC;AAED,6BAAoC,SAAqB;IACvD,EAAE,CAAA,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;QACzB,MAAM,CAAC,EAAE,CAAC;IACZ,CAAC;IACD,IAAI,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACvD,MAAM,CAAC,aAAa,CAAC,SAAS,EAAE,EAAE,MAAM,EAAG,IAAI,EAAE,OAAO,EAAE,UAAU,EAAC,CAAE,CAAA;AACzE,CAAC;AAND,kDAMC;AAGD,kBAAyB,UAAgB,EAAE,KAAuB,EAAE,QAAe,EAAE,OAAa,EAAE,QAAmB;IAErH,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,IAAI,SAAS,CAAC;IAC3C,IAAI,YAAY,GAAG,KAAK,CAAC,MAAM,CAAG,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAE,CAAC;IACvF,OAAO,GAAG,IAAI,4BAAY,CAAC,YAAY,EAAE,QAAQ,EAAE,UAAU,CAAE,CAAC;IAChE,OAAO,GAAG,IAAI,4BAAY,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC,CAAC;IACnD,qCAAqC;IAErC,aAAa,CAAC,UAAU,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;AACnE,CAAC;AATD,4BASC;AAED,uBAA8B,UAAgB,EAAE,KAAuB,EAAE,QAAc,EAAE,OAAY,EAAE,aAAsB,EAAE,QAAqB;IAElJ,uUAAuU;IACvU,sUAAsU;IAEtU,uUAAuU;IAEvU,IAAI,SAAS,GAAG,uWAAuW,CAAC;IACxX,IAAI,WAAW,GAAG,gGAAgG,CAAC;IAEnH,QAAQ;IACR,wXAAwX;IAExX,IAAI,OAAO,GACX;QACE,sHAAsH;QACtH,0HAA0H;QAC1H,sHAAsH;QACtH,yHAAyH;QACzH,sHAAsH;QACtH,0HAA0H;QAC1H,sHAAsH;QACtH,0HAA0H;KAC3H,CAAC;IAEF,IAAI,IAAI,GAAG;QACT,EAAE,GAAG,EAAG,CAAC,EAAG,MAAM,EAAG,EAAE,EAAE,SAAS,EAAG,EAAE,EAAE,GAAG,EAAG,QAAQ,EAAC;QACxD,EAAE,GAAG,EAAG,CAAC,EAAG,MAAM,EAAG,EAAE,EAAE,SAAS,EAAG,EAAE,EAAE,GAAG,EAAG,QAAQ,EAAC;QAC1D,4DAA4D;QAC1D,EAAE,GAAG,EAAG,CAAC,EAAG,MAAM,EAAG,EAAE,EAAE,SAAS,EAAG,EAAE,EAAE,GAAG,EAAG,QAAQ,EAAC;QAC1D,4DAA4D;QAC1D,EAAE,GAAG,EAAG,CAAC,EAAG,MAAM,EAAG,EAAE,EAAE,SAAS,EAAG,EAAE,EAAE,GAAG,EAAG,QAAQ,EAAC;QAC1D,6DAA6D;QAC3D,EAAE,GAAG,EAAE,EAAE,EAAG,MAAM,EAAG,EAAE,EAAE,SAAS,EAAG,EAAE,EAAE,GAAG,EAAG,QAAQ,EAAC;QACxD,EAAE,GAAG,EAAE,EAAE,EAAG,MAAM,EAAG,EAAE,EAAE,SAAS,EAAG,EAAE,EAAE,GAAG,EAAG,QAAQ,EAAC;QACxD,EAAE,GAAG,EAAE,EAAE,EAAG,MAAM,EAAG,EAAE,EAAE,SAAS,EAAG,EAAE,EAAE,GAAG,EAAG,QAAQ,EAAC;QACxD,EAAE,GAAG,EAAE,EAAE,EAAG,MAAM,EAAG,EAAE,EAAE,SAAS,EAAG,EAAE,EAAE,GAAG,EAAG,QAAQ,EAAC;KACzD,CAAC;IACF,IAAI,CAAC,OAAO,CAAE,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,GAAG,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAE,CAAC;IAC7D,IAAI,CAAC,OAAO,CAAE,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,GAAG,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAE,CAAC;IAC7D,IAAI,CAAC,OAAO,CAAE,KAAK,IAAI,KAAK,CAAC,WAAW,CAAC,GAAG,SAAS,CAAE,CAAC;IACxD,IAAI,CAAC,OAAO,CAAE,KAAK,IAAI,KAAK,CAAC,WAAW,CAAC,GAAG,WAAW,CAAE,CAAC;IAC1D,IAAI,CAAC,OAAO,CAAE,KAAK,IAAI,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAE,CAAC;IAE9C,IAAI,IAAI,GAAG,cAAc,CAAC,OAAO,CAAC,CAAC;IAInC,oEAAoE;IAEpE,0HAA0H;IAC1H,uEAAuE;IACvE,0GAA0G;IAC1G,uEAAuE;IAKvE,IAAI,aAAa,GAAG,UAAS,KAAc,EAAE,IAAU,EAAE,MAAW;QAElE,IAAI,CAAC,GAAG,OAAO,CAAC,qBAAqB,CAAC,OAAO,CAAC,KAAK,GAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAE,MAC1D,OAAO,CAAC,qBAAqB,CAAC,OAAO,CAAC,KAAK,GAAC,CAAC,CAAC,CAAC,CAChD,CAAC,IAAI,CAAE;YAEJ,EAAE,CAAC,CAAC,KAAK,GAAC,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC9B,IAAI,EAAE,CAAC;YACT,CAAC;YACD,IAAI,CAAC,CAAC;gBACJ,UAAU,CAAE;oBACV,aAAa,CAAC,KAAK,GAAC,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;gBACvC,CAAC,EAAE,IAAI,CAAC,CAAC;YACb,CAAC;QACH,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IACrB,CAAC,CAAA;IAED,qBAAqB,OAA2B;QAC9C,MAAM,CAAC,IAAI,OAAO,CAAE,UAAS,OAAO,EAAE,MAAM;YAC1C,aAAa,CAAC,CAAC,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;QACpC,CAAC,CAAC,CAAA;IACJ,CAAC;IAED,IAAI,QAAQ,GAAG,UAAU,EAAE;QACzB,IAAI,GAAG,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;QACvB,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACrB,cAAc,CAAC,UAAU,CAAC,CAAC;QAC3B,IAAI,UAAU,GAAG,mBAAmB,CAAC,UAAU,CAAC,CAAC;QACjD,EAAE,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;QAC5C,OAAO,CAAC,GAAG,CAAC,SAAS,GAAG,UAAU,GAAG,IAAI,CAAC,CAAC;QAC3C,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAC1B,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACvB,OAAO,CAAC,WAAW,EAAE,CAAC;QACtB,0BAA0B;QAC1B,oDAAoD;QACpD,2DAA2D;QAE3D,mBAAmB;QACnB,EAAE,KAAK,CAAC;QACR,EAAE,CAAA,CAAC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;YACxB,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,CAAE;gBACzB,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;gBACzB,aAAa,CAAC,UAAU,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;YACvE,CAAC,CAAC,CAAC;QACL,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;YAC3B,OAAO,CAAC,IAAI,EAAE,CAAC;YACf,EAAE,CAAA,CAAC,CAAC,QAAS,CAAC,CAAC,CAAC;gBACd,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAClB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,QAAQ,EAAE,CAAC;YACb,CAAC;QACH,CAAC;IACH,CAAC,CAAC;IAEF,MAAM,GAAG,OAAO,CAAC,aAAa,CAAE,KAAK,CAAC,aAAa,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,aAAa,CAAC,CAAC,SAAS,EAAE,KAAK,CAAC,aAAa,CAAC,CAAC,QAAQ,EAAE,EAAC,UAAU,EAAG,IAAI,EAAG,YAAY,EAAG,KAAK,CAAC,aAAa,CAAC,CAAC,YAAY,EAAE,EAC9L;QACE,QAAQ,EAAG,YAAY;QACvB,IAAI,EAAG,QAAQ;KAChB,CAAC,CAAC;IAEL,OAAO,CAAC,WAAW,EAAE,CAAC;IACtB,IAAI,MAAM,CAAC;IACX;cACU;IAEV,0DAA0D;IAC1D;;;;;;MAME;AAEJ,CAAC;AArID,sCAqIC;AAAA,CAAC,CAAC,kBAAkB","file":"averages.js","sourcesContent":["\n\nimport {Pool} from 'jdbc';\nimport { ParallelExec } from './parallel_exec';\nimport { ParallelPool } from './parallel_pool';\n\nimport * as csv_stringify from 'csv-stringify/lib/sync';\nimport * as debug from 'debug';\nimport { INSPECT_MAX_BYTES } from 'buffer';\nconst debuglog = debug('averages');\n'use strict';\nimport * as _ from 'lodash';\n/**\n * Responses of a dispatcher\n */\nexport const enum ResponseCode {\n  NOMATCH = 0,\n  EXEC,\n  QUERY\n}\n\n\nimport { ISQLExecutor, IParallelOp, Status,\n  Mode,\n  IRun,\n  Metrics,\n  IMetrics,\n  ICallbacks,\n  IOptions,\n  IParallelExecutor,\n  ITimingMap,\n  IResultRec,\n  ITimingRec,\n  IStatementRun} from './constants';\n\n\n\n//import { ParallelPool, SQLExec, ParallelExecutor, Constants } from './parallel_exec';\n//import { IResultRec } from './constants';\n\nvar index = 0;\nvar allresults = [];\n\nvar SQLExec2 = require('./sqlexec.js');\nvar SQLExec = SQLExec2.SQLExec;\n\n//import {SQLExec} from './sqlexec.js';\nimport {Forks} from './sqlexec_remote';\n\nvar parpool : ParallelPool = undefined;\nvar parexec : IParallelExecutor = undefined;\n\n/*\nexport function isTerminated(op : IParallelOp) : boolean\n{\n  if (op.cp_running > 0) {\n    return false;\n  }\n  debuglog(' t/s/f  ' + op.tag + ' ' + op.options.terminate_nr  + '/' + op.metrics.count_started + '/' + op.metrics.count_total);\n  if (op.options && (op.options.terminate_nr > 0) && op.metrics.count_total >= op.options.terminate_nr )\n  {\n    op.status = Status.STOPPED;\n    return true;\n  }\n  if (op.options.continuous && (op.status != Status.STOPPED) && (op.status != Status.DONE))\n    return false;\n  if (op.options.continuous && op.options.every_t && op.status == Status.STOPPED) {\n    return true;\n  }\n  return op.slots.every( run => run.status == Status.DONE );\n}*/\n\n\nvar t_total : number = 0;\n\n/*\nexport function recordStart(op : IParallelOp, slot: IRun)\n{\n  op.metrics.parallel++;\n  if( op.t_started == 0) {\n    op.t_started = Date.now();\n  }\n  slot.status = Status.RUNNING;\n  console.log('S' + (Date.now()- t_total) + ' ' +  (Date.now()- op.t_started) + \"S:\"  + op.parallel + \" \" + op.metrics.count_started + \"/\" + op.metrics.count_total + \"/\" + op.metrics.count_bad + \" \" + op.name);\n  slot.duration = Date.now();\n}\n\nexport function recordEnd(op : IParallelOp, slot: IRun, rc : boolean, res : any)\n{\n  slot.status = Status.DONE;\n  op.metrics.parallel--;\n  op.metrics.count_total++;\n  slot.duration = Date.now() - slot.duration;\n  op.metrics.sum_duration_all += slot.duration;\n  console.log( 'E' + (Date.now()- t_total) + ' ' + (Date.now()- op.t_started) + \"E:\"  + op.parallel + \" \" + op.metrics.count_started + \"/\" + op.metrics.count_total + \"/\" + op.metrics.count_ok + \"/\" + op.metrics.count_bad + ' ' +  slot.duration + ' ' + slot.index + ' len=' + (_.isArray(res) ?  res.length : res)  + ' ' + op.name); //\n  debuglog(JSON.stringify(res));\n  if( rc )\n  {\n    op.metrics.count_ok++;\n  }\n  else {\n    op.metrics.count_bad++;\n  }\n  var d = new Date();\n  if (rc && op.callbacks && op.callbacks.result ) {\n    // console.log('having result ' + JSON.stringify(res));\n    try {\n      op.callbacks.result(undefined, res);\n    } catch( ex) {\n      console.log(ex.toString());\n      console.log(ex.stack);\n    }\n  }\n  op.allresults.push({ ts :  d.toUTCString(), t : d.getTime(), delta_t : d.getTime() - op.t_started, rc : rc, res : res});\n  if (rc && op.callbacks && op.callbacks.progress)\n  {\n    if (rc && op.callbacks && op.callbacks.progress) {\n      try {\n        op.callbacks.progress(op);\n      } catch( ex) {\n          console.log(ex.toString());\n          console.log(ex.stack);\n      }\n    }\n  }\n}\n\nexport function recordOk(op: IParallelOp, run: IRun, res : any) {\n /-* res.conn.close(function(err, ok) {\n    if(err)\n     console.log('error closing' + err);\n  });*-/\n  recordEnd(op, run, true, res.result);\n}\n\nexport function recordBad(op: IParallelOp, run: IRun, res : any) {\n  console.log('BADD!!!!' + res);\n  recordEnd(op,run, false, res);\n}\n*/\n\n\nvar tcnt = 0;\n\nexport function startOpMonitor(parexec : IParallelExecutor) {\n\n  parexec.startOpRepeat(\n    \"monitor\",\n    'SELECT * FROM SYS.INTERNAL_REL_NODE_RT_AVG;',\n    4,\n    {\n      forcename : \"monitor\",\n      continuous : true,\n      t_last : 0,\n      every_t : 2000, // every second!\n    },\n    /*callbacks :*/\n    {\n      result : function(err, res) {\n        if(!err) {\n          var timing = makeTimingRecord(res);\n          registerTiming(Date.now(), timing);\n        }\n      }\n    }\n  )\n  /*\n  var d = new Date();\n  var op: IParallelOp = {\n    tag : \"monitor\",\n    name: \"monitor\",\n    statement: 'SELECT * FROM SYS.INTERNAL_REL_NODE_RT_AVG;',\n    t_started : 0,\n    mode : Mode.PARALLEL,\n    status: Status.RUNNING,\n    parallel : 4,\n    options : {\n      continuous : true,\n      t_last : 0,\n      every_t : 2000, // every second!\n    },\n    cps : [],\n    cp_running : 0,\n    slots: [],\n    timings: [],\n    allresults : [],\n    metrics : new Metrics(),\n    callbacks : {\n      result : function(err, res) {\n        if(!err) {\n          var timing = makeTimingRecord(res);\n          registerTiming(Date.now(), timing);\n        }\n      }\n    }\n  };\n  *\n  handles.set(op.name, op);\n  return op.name;\n}\n*/\n}\n\nvar cnt = 0;\nimport * as child_process from 'child_process';\nimport * as fs from 'fs';\nimport { removeListener, fork } from 'cluster';\nimport { LOADIPHLPAPI } from 'dns';\n/**\n *  execute a statement repeatedly until one calls close on the handle.\n *\n *\n */\n/*\nexport function XstartOpRepeat(tag: string, statement: string, parallel: number, options: IOptions = undefined, cb : ICallbacks = undefined): string {\n  var d = new Date();\n  var op: IParallelOp = {\n    tag : tag,\n    name: tag + '_' + cnt++,\n    statement: statement,\n    t_started : 0,\n    mode : Mode.PARALLEL,\n    status: Status.RUNNING,\n    parallel: parallel,\n    options : {\n      continuous : true,\n      terminate_nr : options && options.terminate_nr,\n      terminate_delta_t : options && options.terminate_delta_t,\n    },\n    cps :[],\n    cp_running: 0,\n    slots: [],\n    timings: [],\n    allresults : [],\n    callbacks : cb,\n    metrics : new Metrics()\n  };\n\n  // the jdbc driver is limiting to ~4 parallel requests\n  var terminate_nr = options.terminate_nr;\n  xhandles.set(op.name, op);\n  return op.name;\n}*/\n\nexport function dumpProgress(op : IParallelOp) {\n  var avg = getBestAvg(op.t_started, op.timings);\n  console.log(' dump progress ' + op.metrics.count_total + ' timings: ' + (op.timings && op.timings.length));\n  if( op.metrics.count_total > 1) {\n    console.log( op.metrics.count_total * 1000 * 60 / (Date.now() - op.t_started) + ' qps; ' + (op.metrics.count_bad * 100 / op.metrics.count_total) +  ' BEST_AVG:' + JSON.stringify(avg));\n  }\n}\nexport interface IResult {\nTAG: string,\nQPM : number,\nBAD : number,\nPAR : number,\nDUR : number,\nDDP : number,\nMAXM : number,\nCPU : number,\nMEM : number,\nMEU : number,\nPAR_N : number,\nQPM_N : number,\nDUR_N : number\n};\n\nexport function dumpDone(op : IParallelOp): IResult {\n  console.log(\"******* DONE \");\n  var avg = getBestAvg(op.t_started, op.timings);\n  console.log( op.metrics.count_total * 1000 * 60 / (Date.now() - op.t_started) + ' qps' + (op.metrics.count_bad * 100 / op.metrics.count_total) +  ' BEST_AVG:' + JSON.stringify(avg));\n  var avgx : any = avg.values;\n  console.log( 'QPM\\t|BAD%\\t|PAR'\n          + '\\t|DUR'\n          + '\\t|DDP'\n          + '\\t|MAX_MEM'\n          + '\\t|CPU%'\n          + '\\t|MEM%'\n          + '\\t|MEU'\n          + '\\t|QPM_N'\n          + '\\t|PAR_P'\n          + '\\t|AGGR_PLAN_EXEC_DURATION'\n          )\n  var result : IResult = {\n    TAG : op.tag,\n    QPM : Math.floor(op.metrics.count_total * 1000 * 60 / (Date.now() - op.t_started)) ,\n    BAD : (op.metrics.count_bad * 100 / op.metrics.count_total),\n    PAR :  (op.parallel ),\n    DUR : Math.floor(op.metrics.sum_duration_all / (100*op.metrics.count_total ))/10,\n    DDP : Math.floor(op.metrics.sum_duration_all / (100*op.parallel*op.metrics.count_total ))/10,\n    MAXM : avgx.MAX_MEM_EVER ,\n    CPU :  avgx.CPU_UTILIZATION,\n    MEM : avgx.MEM_UTILIZATION,\n    MEU : avgx.MEM_USAGE,\n    QPM_N : avgx.QUERY_PER_MIN,\n    PAR_N :  avgx.NR_PARALLEL_PLAN,\n    DUR_N : avgx.AGGR_PLAN_EXEC_DURATION\n  };\n  dumpAllResults([result]);\n  console.log( result.TAG +\n       + '\\t|' + result.QPM\n       + '\\t|' + result.BAD\n       + '\\t|' + (op.parallel )\n       + '\\t|' + result.DUR,\n       + '\\t|' + result.DDP,\n       + '\\t|' + avgx.MAX_MEM_EVER\n       + '   \\t|' + avgx.CPU_UTILIZATION\n       + '\\t|' + result.MEM,\n       + '\\t|' + result.MEU,\n       + '\\t|' + avgx.NR_PARALLEL_PLAN\n       + '\\t|' + avgx.QUERY_PER_MIN\n       + '\\t|' + avgx.AGGR_PLAN_EXEC_DURATION\n  );\n  return result;\n}\n\nexport function makeTimingRecord(res : any) : ITimingMap {\n  var result : ITimingMap = new Map<string, Map<number, number> >();\n  Keys.forEach(key => {\n    res.forEach( rec => {\n      if (rec.NAME == key) {\n        debuglog( ' found record ' + rec.VALUE + \" \" + JSON.stringify(rec));\n        if(!result.has(key)) {\n          result.set(key, new Map<number,number>());\n        }\n        var mp = result.get(key);\n        mp.set(parseInt(rec.NR), parseInt(rec.VALUE));\n      }\n    });\n  });\n  return result;\n}\n\nexport function registerTiming( time : number, rec : ITimingMap)\n{\n  var handles = parexec.getHandles();\n  handles.forEach(function(hndl) {\n    var op = parexec.getOp(hndl);\n    if(op.status != Status.STOPPED)\n    {\n      op.timings.push({ time : time, rec : rec});\n      debuglog( 'adding timing length now' + op.timings.length);\n    }\n  });\n}\n\nexport function getBestTime(start : number, end : number )\n{\n  return start + (end - start)*0.8;\n}\n\nexport function getAvgLength( start : number, end : number )\n{\n  return (end-start) * 0.2;\n}\n\nexport class IAvgRecord {\n  MAX_MEM_USAGE_30s : number = 0;\n  MEM_USAGE : number = 0;\n  AGGR_PLAN_EXEC_DURATION : number = 0;\n  QUERY_PER_MIN : number = 0;\n  CPU_UTILIZATION : number = 0;\n  MEM_UTILIZATION : number = 0;\n  MAX_MEM_EVER : number = 0;\n  NR_PARALLEL_PLAN : number = 0;\n  PLAN_EXEC_DURATION : number = 0;\n  constructor() {}\n};\n\nexport class IAvgSet {\n  time : number = 0;\n  avg : number = 0;\n  values : IAvgRecord = new IAvgRecord();\n};\n\nexport const Keys = Array.from(Object.keys(new IAvgRecord()));\nexport function getBestAvg(start : number,  recs :  ITimingRec[]) : IAvgSet\n{\n  // find the maximum of ITimingRec[]\n  //recs.forEach(entry => console.log(' time is ' + entry.time ))\n  const end_time = recs.reduce( (prev,current) => (current.time > prev)? current.time: prev , 0);\n  const best_time = getBestTime(start, end_time);\n  debuglog( 'start' + (start - t_total) + ' end' + (end_time - t_total) + ' best' + ( best_time - t_total) );\n  if( recs.length < 3)\n  {\n    console.log(\"warning, timing length low\" + recs.length);\n  }\n  recs.forEach(rec =>\n    debuglog('at ' + (rec.time - t_total)));\n  const bestTimingRec = recs.reduce( (prev, current) =>  (!prev || (current.time < best_time)) ? current : prev , undefined);\n  var result : IAvgSet =\n  {\n    time : 0,\n    avg : 0,\n    values : new IAvgRecord\n  };\n  const best_avg = getAvgLength(start, end_time);\n  debuglog('best avg length ' + best_avg);\n  var actual_best_avg = 0;\n  if ( bestTimingRec )\n  {\n    debuglog('got a best record!!');\n    Keys.forEach(key => {\n    var rec = bestTimingRec.rec.get(key);\n    var sortedIntArr = Array.from(rec.keys()).map(k => parseInt(' ' + k)).sort( (a,b) => a-b);\n    debuglog('sortedIntArr' + sortedIntArr);\n    result.values[key] = sortedIntArr.reduce((prev, time) =>\n       {\n         if((time < best_avg))\n         {\n           actual_best_avg = time;\n           return rec.get(time);\n         } else {\n           return prev;\n          }\n        }\n       , 0);\n      });\n    }\n  debuglog('best avg' + actual_best_avg);\n  result.avg = actual_best_avg;\n  result.time = bestTimingRec && bestTimingRec.time;\n  return result;\n}\n\nexport function dumpNice(v : any, len : number) {\n  var s = '' + v;\n  while(s.length < len) {\n    s = ' ' + s;\n  }\n  return s;\n}\n\n\n  //var handle = runner.startOpRepeat('SELECT COUNT(*) FROM T1;', 20);\n\n  //QPM     |BAD%   |PAR    |NR_PARALLEL_PLAN       |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n  //10      |0      |4      |4      |165    |94     |173    |169    |2624\n  //QPM     |BAD%   |PAR    |PAR_P  |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n  //10      |0      |8      |4      |174    |98     |171    |1      |2761\n\n\nexport function dumpAllResults(allresult : IResult[]) {\n  if(allresult.length == 0) {\n    return;\n  }\n  var s1 = Object.keys(allresult[0]).map( key => dumpNice(key,10)).join(\",\");\n  console.log(s1);\n  allresult.forEach(entry =>\n  {\n    var sn =  Object.keys(entry).map( key => dumpNice(entry[key],10)).join(',');\n    console.log(sn);\n  });\n}\n\nexport function dumpAllResultsToCSV(allresult : IResult[]) {\n  if(allresult.length == 0) {\n    return \"\";\n  }\n  var headersarr = Array.from(Object.keys(allresult[0]));\n  return csv_stringify(allresult, { header : true, columns: headersarr} )\n}\n\n\nexport function startRun(fullconfig : any, input : IStatementRun[], testpool : Pool, options : any, callback : ()=>void)\n{\n  options.fnout = options.fnout || 'out.csv';\n  var max_parallel = input.reduce(  (prev, entry) => Math.max(prev, entry.parallel), 0 );\n  parpool = new ParallelPool(max_parallel, testpool, fullconfig );\n  parexec = new ParallelExec(parpool.getExecutors());\n  //var hndl = startOpMonitor(parexec);\n\n  startSequence(fullconfig, input, testpool, options, 0, callback);\n}\n\nexport function startSequence(fullconfig : any, input : IStatementRun[], testpool: Pool, options: any, current_index : number, callback : () => void) {\n\n  //var tcp001 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'FOB\\' AND T1.L_QUANTITY > 2 AND T2.L_QUANTITY > 10 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n  //var tcp001 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'B\\' AND T1.L_QUANTITY > 10 AND T2.L_QUANTITY > 10 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n\n  //var tcp001 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'B\\' AND T1.L_QUANTITY > 10 AND T2.L_QUANTITY > 100 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n\n  var tcp_001_4 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'FOB\\' AND T1.L_PARTKEY > 1000 AND T2.L_PARTKEY > 1000 AND T1.L_QUANTITY > 2 AND T2.L_QUANTITY > 10 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n  var parq_1m_zip = 'select max(VCHAR50RNDVL), vchar4dic6, avg(UINT64_RND) from GEN_1M_PAR_ZIP group by VCHAR4DIC6;';\n\n  //ALTERD\n  //tcp_001_4 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'FOB\\' AND T1.L_PARTKEY > 1000 AND T2.L_PARTKEY > 1000 AND T1.L_QUANTITY > 2 AND T2.L_QUANTITY > 1000 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n\n  var interim : string[] =\n  [\n    `ALTER SYSTEM ALTER CONFIGURATION ('VORA', 'SYSTEM') SET ('RELATIONAL', 'QUOTA_OPEN_TXN_SIZE') = 18 WITH RECONFIGURE;`,\n    `ALTER SYSTEM ALTER CONFIGURATION ('VORA', 'SYSTEM') SET ('RELATIONAL', 'QUOTA_WAITING_TXN_SIZE') = 10  WITH RECONFIGURE;`,\n    `ALTER SYSTEM ALTER CONFIGURATION ('VORA', 'SYSTEM') SET ('RELATIONAL', 'QUOTA_OPEN_TXN_SIZE') = 19 WITH RECONFIGURE;`,\n    `ALTER SYSTEM ALTER CONFIGURATION ('VORA', 'SYSTEM') SET ('RELATIONAL', 'QUOTA_WAITING_TXN_SIZE') = 9  WITH RECONFIGURE;`,\n    `ALTER SYSTEM ALTER CONFIGURATION ('VORA', 'SYSTEM') SET ('RELATIONAL', 'QUOTA_OPEN_TXN_SIZE') = 18 WITH RECONFIGURE;`,\n    `ALTER SYSTEM ALTER CONFIGURATION ('VORA', 'SYSTEM') SET ('RELATIONAL', 'QUOTA_WAITING_TXN_SIZE') = 10  WITH RECONFIGURE;`,\n    `ALTER SYSTEM ALTER CONFIGURATION ('VORA', 'SYSTEM') SET ('RELATIONAL', 'QUOTA_OPEN_TXN_SIZE') = -1 WITH RECONFIGURE;`,\n    `ALTER SYSTEM ALTER CONFIGURATION ('VORA', 'SYSTEM') SET ('RELATIONAL', 'QUOTA_WAITING_TXN_SIZE') = -1  WITH RECONFIGURE;`,\n  ];\n\n  var arrx = [\n    { PAR : 1,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR : 2,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n  // { PAR : 3,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR : 4,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n  // { PAR : 6,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR : 8,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n  //  { PAR :10,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :12,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :16,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :20,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :32,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'}\n  ];\n  arrx.forEach( entry => entry['TAG'] = 'TCP_P_' + entry.PAR );\n  arrx.forEach( entry => entry['TAG'] = 'P1Z_P_' + entry.PAR );\n  arrx.forEach( entry => entry['statement'] = tcp_001_4 );\n  arrx.forEach( entry => entry['statement'] = parq_1m_zip );\n  arrx.forEach( entry => entry['MAX_NR'] = 40 );\n\n  var hndl = startOpMonitor(parexec);\n\n\n\n  //var handle = runner.startOpRepeat('SELECT COUNT(*) FROM T1;', 20);\n\n  //QPM     |BAD%   |PAR    |NR_PARALLEL_PLAN       |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n  //10      |0      |4      |4      |165    |94     |173    |169    |2624\n  //QPM     |BAD%   |PAR    |PAR_P  |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n  //10      |0      |8      |4      |174    |98     |171    |1      |2761\n\n\n\n\n  var runOneInterim = function(index : number, done : any, reject: any)\n  {\n    var r = parexec.startSequentialSimple(interim[index+0]).then( ()=>\n        parexec.startSequentialSimple(interim[index+1])\n      ).then( ()=> {\n\n          if (index+2 == interim.length) {\n            done();\n          }\n          else {\n            setTimeout( function() {\n              runOneInterim(index+2, done, reject);\n            }, 2000);\n        }\n      }).catch(reject);\n  }\n\n  function runInterims(parexec : IParallelExecutor) : Promise<any> {\n    return new Promise( function(resolve, reject ) {\n      runOneInterim(0, resolve, reject);\n    })\n  }\n\n  var makeNext = function (op)  {\n    var res = dumpDone(op);\n    allresults.push(res);\n    dumpAllResults(allresults);\n    var csvcontent = dumpAllResultsToCSV(allresults);\n    fs.writeFileSync(options.fnout, csvcontent);\n    console.log('>>csv\\n' + csvcontent + '\\n');\n    parexec.stopOp('monitor');\n    parexec.stopOp(handle);\n    parexec.triggerLoop();\n    // run the cleanup scripts\n    // we want to temper with the config to clear maxmem\n    // but due to the synchronization delay, we wait 3 seconds.\n\n    //loopIt(executor);\n    ++index;\n    if(index < input.length) {\n      runInterims(parexec).then( ()=> {\n        console.log(\"*** INDEX\");\n        startSequence(fullconfig, input, testpool, options, index, callback);\n      });\n    } else {\n      console.log('stop forks ');\n      parpool.stop();\n      if(!callback ) {\n        process.exit(0);\n      } else {\n        callback();\n      }\n    }\n  };\n\n  handle = parexec.startOpRepeat( input[current_index].tag, input[current_index].statement, input[current_index].parallel, {continuous : true,  terminate_nr : input[current_index].terminate_nr },\n    {\n      progress : dumpProgress,\n      done : makeNext\n    });\n\n  parexec.triggerLoop();\n  var handle;\n  /*setTimeout( function() {\n  }, 500);*/\n\n  // beware, this only stops when all queries are completed;\n  /*\n  setTimeout( function() {\n    console.log('stopping now');\n    stopOp(handle);\n    loopIt(executor);\n  }, 200000);\n  */\n\n}; /* startsequence*/\n"],"sourceRoot":"."}