{"version":3,"sources":["../src/averages.ts"],"names":[],"mappings":"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","file":"averages.js","sourcesContent":["\n\nimport {Pool} from 'jdbc';\nimport {ParallelExec} from './parallel_exec';\nimport * as csv_stringify from 'csv-stringify/lib/sync';\nimport * as debug from 'debug';\nimport { INSPECT_MAX_BYTES } from 'buffer';\nconst debuglog = debug('average');\n'use strict';\nimport * as _ from 'lodash';\n/**\n * Responses of a dispatcher\n */\nexport const enum ResponseCode {\n  NOMATCH = 0,\n  EXEC,\n  QUERY\n}\n\n\nimport { ISQLExecutor, IParallelOp, Status,\n  Mode,\n  IRun,\n  Metrics,\n  IMetrics,\n  ICallbacks,\n  IOptions,\n  IParallelExecutor,\n  ITimingMap,\n  IResultRec,\n  ITimingRec } from './constants';\n\nvar handles = new Map<string, IParallelOp>();\n\n\nvar index = 0;\nvar allresults = [];\n\nvar forks : Forks = undefined;\n\nvar SQLExec2 = require('./sqlexec.js');\nvar SQLExec = SQLExec2.SQLExec;\n\n//import {SQLExec} from './sqlexec.js';\nimport {Forks} from './sqlexec_remote';\n\nvar parexec : IParallelExecutor = undefined;\n\n/*\nexport function isTerminated(op : IParallelOp) : boolean\n{\n  if (op.cp_running > 0) {\n    return false;\n  }\n  debuglog(' t/s/f  ' + op.tag + ' ' + op.options.terminate_nr  + '/' + op.metrics.count_started + '/' + op.metrics.count_total);\n  if (op.options && (op.options.terminate_nr > 0) && op.metrics.count_total >= op.options.terminate_nr )\n  {\n    op.status = Status.STOPPED;\n    return true;\n  }\n  if (op.options.continuous && (op.status != Status.STOPPED) && (op.status != Status.DONE))\n    return false;\n  if (op.options.continuous && op.options.every_t && op.status == Status.STOPPED) {\n    return true;\n  }\n  return op.slots.every( run => run.status == Status.DONE );\n}*/\n\n\nvar t_total : number = 0;\n\n/*\nexport function recordStart(op : IParallelOp, slot: IRun)\n{\n  op.metrics.parallel++;\n  if( op.t_started == 0) {\n    op.t_started = Date.now();\n  }\n  slot.status = Status.RUNNING;\n  console.log('S' + (Date.now()- t_total) + ' ' +  (Date.now()- op.t_started) + \"S:\"  + op.parallel + \" \" + op.metrics.count_started + \"/\" + op.metrics.count_total + \"/\" + op.metrics.count_bad + \" \" + op.name);\n  slot.duration = Date.now();\n}\n\nexport function recordEnd(op : IParallelOp, slot: IRun, rc : boolean, res : any)\n{\n  slot.status = Status.DONE;\n  op.metrics.parallel--;\n  op.metrics.count_total++;\n  slot.duration = Date.now() - slot.duration;\n  op.metrics.sum_duration_all += slot.duration;\n  console.log( 'E' + (Date.now()- t_total) + ' ' + (Date.now()- op.t_started) + \"E:\"  + op.parallel + \" \" + op.metrics.count_started + \"/\" + op.metrics.count_total + \"/\" + op.metrics.count_ok + \"/\" + op.metrics.count_bad + ' ' +  slot.duration + ' ' + slot.index + ' len=' + (_.isArray(res) ?  res.length : res)  + ' ' + op.name); //\n  debuglog(JSON.stringify(res));\n  if( rc )\n  {\n    op.metrics.count_ok++;\n  }\n  else {\n    op.metrics.count_bad++;\n  }\n  var d = new Date();\n  if (rc && op.callbacks && op.callbacks.result ) {\n    // console.log('having result ' + JSON.stringify(res));\n    try {\n      op.callbacks.result(undefined, res);\n    } catch( ex) {\n      console.log(ex.toString());\n      console.log(ex.stack);\n    }\n  }\n  op.allresults.push({ ts :  d.toUTCString(), t : d.getTime(), delta_t : d.getTime() - op.t_started, rc : rc, res : res});\n  if (rc && op.callbacks && op.callbacks.progress)\n  {\n    if (rc && op.callbacks && op.callbacks.progress) {\n      try {\n        op.callbacks.progress(op);\n      } catch( ex) {\n          console.log(ex.toString());\n          console.log(ex.stack);\n      }\n    }\n  }\n}\n\nexport function recordOk(op: IParallelOp, run: IRun, res : any) {\n /-* res.conn.close(function(err, ok) {\n    if(err)\n     console.log('error closing' + err);\n  });*-/\n  recordEnd(op, run, true, res.result);\n}\n\nexport function recordBad(op: IParallelOp, run: IRun, res : any) {\n  console.log('BADD!!!!' + res);\n  recordEnd(op,run, false, res);\n}\n*/\n\n\nvar tcnt = 0;\n\nexport function startOpMonitor(parexec : IParallelExecutor) {\n\n  parexec.startOpRepeat(\n    \"monitor\",\n    'SELECT * FROM SYS.INTERNAL_REL_NODE_RT_AVG;',\n    4,\n    {\n      forcename : \"monitor\",\n      continuous : true,\n      t_last : 0,\n      every_t : 2000, // every second!\n    },\n    /*callbacks :*/\n    {\n      result : function(err, res) {\n        if(!err) {\n          var timing = makeTimingRecord(res);\n          registerTiming(Date.now(), timing);\n        }\n      }\n    }\n  )\n  /*\n  var d = new Date();\n  var op: IParallelOp = {\n    tag : \"monitor\",\n    name: \"monitor\",\n    statement: 'SELECT * FROM SYS.INTERNAL_REL_NODE_RT_AVG;',\n    t_started : 0,\n    mode : Mode.PARALLEL,\n    status: Status.RUNNING,\n    parallel : 4,\n    options : {\n      continuous : true,\n      t_last : 0,\n      every_t : 2000, // every second!\n    },\n    cps : [],\n    cp_running : 0,\n    slots: [],\n    timings: [],\n    allresults : [],\n    metrics : new Metrics(),\n    callbacks : {\n      result : function(err, res) {\n        if(!err) {\n          var timing = makeTimingRecord(res);\n          registerTiming(Date.now(), timing);\n        }\n      }\n    }\n  };\n  *\n  handles.set(op.name, op);\n  return op.name;\n}\n*/\n}\n\nvar cnt = 0;\nimport * as child_process from 'child_process';\nimport * as fs from 'fs';\nimport { removeListener, fork } from 'cluster';\nimport { LOADIPHLPAPI } from 'dns';\n/**\n *  execute a statement repeatedly until one calls close on the handle.\n *\n *\n */\nexport function startOpRepeat(tag: string, statement: string, parallel: number, options: IOptions = undefined, cb : ICallbacks = undefined): string {\n  var d = new Date();\n  var op: IParallelOp = {\n    tag : tag,\n    name: tag + '_' + cnt++,\n    statement: statement,\n    t_started : 0,\n    mode : Mode.PARALLEL,\n    status: Status.RUNNING,\n    parallel: parallel,\n    options : {\n      continuous : true,\n      terminate_nr : options && options.terminate_nr,\n      terminate_delta_t : options && options.terminate_delta_t,\n    },\n    cps :[],\n    cp_running: 0,\n    slots: [],\n    timings: [],\n    allresults : [],\n    callbacks : cb,\n    metrics : new Metrics()\n  };\n\n  // the jdbc driver is limiting to ~4 parallel requests\n  var terminate_nr = options.terminate_nr;\n  handles.set(op.name, op);\n  return op.name;\n}\n\nexport function dumpProgress(op : IParallelOp) {\n  var avg = getBestAvg(op.t_started, op.timings);\n  console.log(' dump progress ' + op.metrics.count_total);\n  if( op.metrics.count_total > 1) {\n    console.log( op.metrics.count_total * 1000 * 60 / (Date.now() - op.t_started) + ' qps; ' + (op.metrics.count_bad * 100 / op.metrics.count_total) +  ' BEST_AVG:' + JSON.stringify(avg));\n  }\n}\nexport interface IResult {\nTAG: string,\nQPM : number,\nBAD : number,\nPAR : number,\nDUR : number,\nDDP : number,\nMAXM : number,\nCPU : number,\nMEM : number,\nMEU : number,\nPAR_N : number,\nQPM_N : number,\nDUR_N : number\n};\n\nexport function dumpDone(op : IParallelOp): IResult {\n  console.log(\"******* DONE \");\n  var avg = getBestAvg(op.t_started, op.timings);\n  console.log( op.metrics.count_total * 1000 * 60 / (Date.now() - op.t_started) + ' qps' + (op.metrics.count_bad * 100 / op.metrics.count_total) +  ' BEST_AVG:' + JSON.stringify(avg));\n  var avgx : any = avg.values;\n  console.log( 'QPM\\t|BAD%\\t|PAR'\n          + '\\t|DUR'\n          + '\\t|DDP'\n          + '\\t|MAX_MEM'\n          + '\\t|CPU%'\n          + '\\t|MEM%'\n          + '\\t|MEU'\n          + '\\t|QPM_N'\n          + '\\t|PAR_P'\n          + '\\t|AGGR_PLAN_EXEC_DURATION'\n          )\n  var result : IResult = {\n    TAG : op.tag,\n    QPM : Math.floor(op.metrics.count_total * 1000 * 60 / (Date.now() - op.t_started)) ,\n    BAD : (op.metrics.count_bad * 100 / op.metrics.count_total),\n    PAR :  (op.parallel ),\n    DUR : Math.floor(op.metrics.sum_duration_all / (100*op.metrics.count_total ))/10,\n    DDP : Math.floor(op.metrics.sum_duration_all / (100*op.parallel*op.metrics.count_total ))/10,\n    MAXM : avgx.MAX_MEM_EVER ,\n    CPU :  avgx.CPU_UTILIZATION,\n    MEM : avgx.MEM_UTILIZATION,\n    MEU : avgx.MEM_USAGE,\n    QPM_N : avgx.QUERY_PER_MIN,\n    PAR_N :  avgx.NR_PARALLEL_PLAN,\n    DUR_N : avgx.AGGR_PLAN_EXEC_DURATION\n  };\n  dumpAllResults([result]);\n  console.log( result.TAG +\n       + '\\t|' + result.QPM\n       + '\\t|' + result.BAD\n       + '\\t|' + (op.parallel )\n       + '\\t|' + result.DUR,\n       + '\\t|' + result.DDP,\n       + '\\t|' + avgx.MAX_MEM_EVER\n       + '   \\t|' + avgx.CPU_UTILIZATION\n       + '\\t|' + result.MEM,\n       + '\\t|' + result.MEU,\n       + '\\t|' + avgx.NR_PARALLEL_PLAN\n       + '\\t|' + avgx.QUERY_PER_MIN\n       + '\\t|' + avgx.AGGR_PLAN_EXEC_DURATION\n  );\n  return result;\n}\n\nexport function makeTimingRecord(res : any) : ITimingMap {\n  var result : ITimingMap = new Map<string, Map<number, number> >();\n  Keys.forEach(key => {\n    res.forEach( rec => {\n      if (rec.NAME == key) {\n        debuglog( ' found record ' + rec.VALUE + \" \" + JSON.stringify(rec));\n        if(!result.has(key)) {\n          result.set(key, new Map<number,number>());\n        }\n        var mp = result.get(key);\n        mp.set(parseInt(rec.NR), parseInt(rec.VALUE));\n      }\n    });\n  });\n  return result;\n}\n\nexport function registerTiming( time : number, rec : ITimingMap)\n{\n  handles.forEach(function(op) {\n    if(op.status != Status.STOPPED)\n    {\n      op.timings.push({ time : time, rec : rec});\n      //console.log( 'timing length now' + op.timings.length);\n    }\n  });\n}\n\nexport function getBestTime(start : number, end : number )\n{\n  return start + (end - start)*0.8;\n}\n\nexport function getAvgLength( start : number, end : number )\n{\n  return (end-start) * 0.2;\n}\n\nexport class IAvgRecord {\n  MAX_MEM_USAGE_30s : number = 0;\n  MEM_USAGE : number = 0;\n  AGGR_PLAN_EXEC_DURATION : number = 0;\n  QUERY_PER_MIN : number = 0;\n  CPU_UTILIZATION : number = 0;\n  MEM_UTILIZATION : number = 0;\n  MAX_MEM_EVER : number = 0;\n  NR_PARALLEL_PLAN : number = 0;\n  PLAN_EXEC_DURATION : number = 0;\n  constructor() {}\n};\n\nexport class IAvgSet {\n  time : number = 0;\n  avg : number = 0;\n  values : IAvgRecord = new IAvgRecord();\n};\n\nexport const Keys = Array.from(Object.keys(new IAvgRecord()));\nexport function getBestAvg(start : number,  recs :  ITimingRec[]) : IAvgSet\n{\n  // find the maximum of ITimingRec[]\n  //recs.forEach(entry => console.log(' time is ' + entry.time ))\n  const end_time = recs.reduce( (prev,current) => (current.time > prev)? current.time: prev , 0);\n  const best_time = getBestTime(start, end_time);\n  debuglog( 'start' + (start - t_total) + ' end' + (end_time - t_total) + ' best' + ( best_time - t_total) );\n  if( recs.length < 3)\n  {\n    console.log(\"warning, timing length low\" + recs.length);\n  }\n  recs.forEach(rec =>\n    debuglog('at ' + (rec.time - t_total)));\n  const bestTimingRec = recs.reduce( (prev, current) =>  (!prev || (current.time < best_time)) ? current : prev , undefined);\n  var result : IAvgSet =\n  {\n    time : 0,\n    avg : 0,\n    values : new IAvgRecord\n  };\n  const best_avg = getAvgLength(start, end_time);\n  debuglog('best avg length ' + best_avg);\n  var actual_best_avg = 0;\n  if ( bestTimingRec )\n  {\n    debuglog('got a best record!!');\n    Keys.forEach(key => {\n    var rec = bestTimingRec.rec.get(key);\n    var sortedIntArr = Array.from(rec.keys()).map(k => parseInt(' ' + k)).sort();\n    debuglog('sortedIntArr' + sortedIntArr);\n    result.values[key] = sortedIntArr.reduce((prev, time) =>\n       {\n         if((time < best_avg))\n         {\n           actual_best_avg = time;\n           return rec.get(time);\n         } else {\n           return prev;\n          }\n        }\n       , 0);\n      });\n    }\n  debuglog('best avg' + actual_best_avg);\n  result.avg = actual_best_avg;\n  result.time = bestTimingRec && bestTimingRec.time;\n  return result;\n}\n\nexport function dumpNice(v : any, len : number) {\n  var s = '' + v;\n  while(s.length < len) {\n    s = ' ' + s;\n  }\n  return s;\n}\n\n\n  //var handle = runner.startOpRepeat('SELECT COUNT(*) FROM T1;', 20);\n\n  //QPM     |BAD%   |PAR    |NR_PARALLEL_PLAN       |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n  //10      |0      |4      |4      |165    |94     |173    |169    |2624\n  //QPM     |BAD%   |PAR    |PAR_P  |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n  //10      |0      |8      |4      |174    |98     |171    |1      |2761\n\n\nexport function dumpAllResults(allresult : IResult[]) {\n  if(allresult.length == 0) {\n    return;\n  }\n  var s1 = Object.keys(allresult[0]).map( key => dumpNice(key,10)).join(\",\");\n  console.log(s1);\n  allresult.forEach(entry =>\n  {\n    var sn =  Object.keys(entry).map( key => dumpNice(entry[key],10)).join(',');\n    console.log(sn);\n  });\n}\n\nexport function dumpAllResultsToCSV(allresult : IResult[]) {\n  if(allresult.length == 0) {\n    return \"\";\n  }\n  var headers = {};\n  var s1 = Object.keys(allresult[0]).map( key =>{ headers[key] = key});\n\n  var headersarr = Array.from(Object.keys(allresult[0]));\n  console.log(csv_stringify([[1,2],[3,4]]));\n\n  console.log(csv_stringify([{a : 1, b: 2}], {\n     header: true, columns : ['a','b']\n    }\n  ));\n\n  return csv_stringify(allresult, { header : true, columns: headersarr} )\n /* var columns = {\n    year: 'birthYear',\n    phone: 'phone'\n   };\n   var stringifier = stringify({ header: true, columns: columns });\n\n\n  console.log(s1);\n  allresult.forEach(entry =>\n  {\n    var sn =  Object.keys(entry).map( key => dumpNice(entry[key],10)).join(',');\n    console.log(sn);\n  });\n  */\n}\n\n\nexport function startSequence(configFileName : string, testpool: Pool, current_index = 0) {\n\n  //var tcp001 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'FOB\\' AND T1.L_QUANTITY > 2 AND T2.L_QUANTITY > 10 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n  //var tcp001 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'B\\' AND T1.L_QUANTITY > 10 AND T2.L_QUANTITY > 10 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n\n  //var tcp001 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'B\\' AND T1.L_QUANTITY > 10 AND T2.L_QUANTITY > 100 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n\n  var tcp_001_4 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'FOB\\' AND T1.L_PARTKEY > 1000 AND T2.L_PARTKEY > 1000 AND T1.L_QUANTITY > 2 AND T2.L_QUANTITY > 10 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n  var parq_1m_zip = 'select max(VCHAR50RNDVL), vchar4dic6, avg(UINT64_RND) from GEN_1M_PAR_ZIP group by VCHAR4DIC6;';\n\n  //ALTERD\n  //tcp_001_4 = 'select count(*), AVG(T1.L_QUANTITY), AVG(T1.L_DISCOUNT + T2.L_DISCOUNT), AVG(T2.L_EXTENDEDPRICE), T2.L_SHIPMODE FROM LINEITEM1 AS T1 JOIN LINEITEM1 AS T2 ON T1.L_SHIPMODE = T2.L_SHIPMODE WHERE T1.L_SHIPMODE <= \\'FOB\\' AND T1.L_PARTKEY > 1000 AND T2.L_PARTKEY > 1000 AND T1.L_QUANTITY > 2 AND T2.L_QUANTITY > 1000 GROUP BY T2.L_SHIPMODE ORDER BY T2.L_SHIPMODE;';\n\n\n  var arr = [\n    { PAR : 1,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR : 2,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n  // { PAR : 3,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR : 4,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n  // { PAR : 6,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR : 8,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n  //  { PAR :10,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :12,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :16,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :20,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'},\n    { PAR :32,  MAX_NR : 40, statement : '', TAG : 'TCP_P1'}\n  ];\n  arr.forEach( entry => entry['TAG'] = 'TCP_P_' + entry.PAR );\n  arr.forEach( entry => entry['TAG'] = 'P1Z_P_' + entry.PAR );\n  arr.forEach( entry => entry['statement'] = tcp_001_4 );\n  arr.forEach( entry => entry['statement'] = parq_1m_zip );\n  arr.forEach( entry => entry['MAX_NR'] = 40 );\n\n\n  if (current_index == 0) {\n    // create the forks!\n    var max_parallel = arr.reduce(  (prev, entry) => Math.max(prev, entry.PAR), 0 );\n    var nrForks = Math.ceil(max_parallel / 4);\n    forks = new Forks(nrForks , configFileName);\n    ;\n  }\n  var hndl = startOpMonitor(parexec);\n\n  var executors : ISQLExecutor[];\n  executors = SQLExec.getExecutors(testpool,4);\n  executors = executors.concat(forks.getExecutors(4));\n  parexec = new ParallelExec(executors);\n  //var handle = runner.startOpRepeat('SELECT COUNT(*) FROM T1;', 20);\n\n  //QPM     |BAD%   |PAR    |NR_PARALLEL_PLAN       |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n  //10      |0      |4      |4      |165    |94     |173    |169    |2624\n  //QPM     |BAD%   |PAR    |PAR_P  |MAX_MEM        |CPU%   |MEM%   |QUERY_PER_MIN  |AGGR_PLAN_EXEC_DURATION\n  //10      |0      |8      |4      |174    |98     |171    |1      |2761\n\n\n  var showOp = dumpProgress;\n  var makeNext = function (op)  {\n    var res = dumpDone(op);\n    allresults.push(res);\n    dumpAllResults(allresults);\n    parexec.stopOp('monitor');\n    parexec.stopOp(handle);\n    parexec.triggerLoop();\n    //loopIt(executor);\n    ++index;\n    if(index < arr.length) {\n      console.log(\"*** INDEX\");\n      startSequence(configFileName, testpool, index);\n    } else {\n      forks.stop();\n    }\n  };\n\n  handle = parexec.startOpRepeat( arr[current_index].TAG, arr[current_index].statement, arr[current_index].PAR, {continuous : true,  terminate_nr : arr[current_index].MAX_NR },\n    {\n      progress : showOp,\n      done : makeNext\n    });\n\n  parexec.triggerLoop();\n  var handle;\n  setTimeout( function() {\n  }, 500);\n\n  // beware, this only stops when all queries are completed;\n  /*\n  setTimeout( function() {\n    console.log('stopping now');\n    stopOp(handle);\n    loopIt(executor);\n  }, 200000);\n  */\n\n}; /* startsequence*/\n"],"sourceRoot":"."}